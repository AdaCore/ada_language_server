# Developing on the Ada Language Server

## Debugging

You can activate traces that show all the server input/output. This is done
by creating a file `$HOME/.als/traces.cfg` with the following contents:

```
ALS.IN=yes > inout.txt:buffer_size=0
ALS.OUT=yes > inout.txt:buffer_size=0
```

When this is present, the ALS will generate a file `$HOME/.als/inout.txt`
which logs the input received and the output sent by the language server.

### Writing tests

To write a functional test for Ada Language Server:

  * Choose a meaninful name for your test, for instance `completion_inside_generics`. 
     We'll refer to this as `<testname>` below
  * Create a new directory `testsuite/ada_lsp/<testname>` containing your test data
  * Activate full in/out language server traces. See the Debugging section above.
  * From the base directory in this repository, run:
     ```
     python scripts/traces_to_test.py <testname> <path_to_the_als_traces_file>
     ```
  * Delete all extra requests, notifications and capabilities those are not related
    to tested fearure. It will help a lot latter when tests are baselined to changed
    protocol, capablitities or message format.
  * Replace the comment at the begining of the test with something meaninful:
  ```
      "comment": [
         "test automatically generated"
      ]
  ```

### Running tests

 * run `make check` to run the entire testsuite
 * to run an individual test, go to `testsuite` and run `sh run.sh ada_lsp/<testname>`
    (you will need `https://github.com/AdaCore/e3-testsuite` installed to do this)

### Other tests

See more about the project testsuite [here](../testsuite/README.md).

## Release VS Code extension

To release new version of VS Code extension just put a tag in format like `21.0.3`,
where `21.0` matches current GNAT Studio version under development. Corresponding
`git` command is
```
   git tag -a 21.0.3
```

Put release notes in the comment of the tag starting with `Release notes` header:
```
Release notes

* <notes 1>
* <notes 2>, etc.
```

Then push it to the GitHub with `git push 21.0.3` or `git push --tags`.
Travis CI will publish the extension on the marketplace.

## Source directories

The repository contains next folders:

* `doc/` - documentation of the project and LSP extensions
* `gnat/` - GNATproject files
* `integration/appveyor/` - Appveyor CI (Windows) integration scripts
* `integration/travis/` - Travis CI (Linux and Mac OS)  integration scripts
* `integration/vscode/ada/` - VS Code extension sources
* `scripts/` - some support scripts
* `ada_language_server/source/ada/` - LSP implementation for Ada language
* `source/client/` - basic client interface
* `source/protocol/` - LSP binding in Ada
* `source/server/` - Common LSP server implementation
* `source/spawn/` - Process spawn/communication API
* `source/tester/` - source of the tester driver
* `testsuite/ada_lsp/` - test suite of LSP in form of request/response

## Protocol synchronization

You can get the latest Language Server Protocol specification from
the https://github.com/microsoft/language-server-protocol.git repository,
`gh-pages` branch.

Currently, we synchronize Ada sources with LSP updates manually. The Ada source to
synchronize is `LSP.Messages` package. The specification of the package contains
TypeScript snippets from the Language Server Protocol specification in form of
comments:
```
   --```typescript
   --interface Message {
   --   jsonrpc: string;
   --}
   --```
```

You can easily extract all such snippets from the specification with the command
```
sed -n -e '/^```typescript/,/^```/p' specification-3-14.md |sed -e 's/^/   --/'
```

To extract corresponding snippets from `lsp-messages.ads` use this:
```
sed -n -e '/^   --```typescript/,/^   --```/p' lsp-messages.ads 
```

Unfortunately we have to reorder Ada declarations to follow _"define before use"_
rule. To restore original order use `awk -f reorder.awk` script. Then you can
compare texts with `diff -u` to see what's changed.

Rules to match method name with corresponding messages are not present in the
TypeScript snippets. So we don't put requests, responses and notifications types
in then `LSP.Messages` package. Instead we have 6 packages divided by message
kind and directions:

* LSP.Messages.Server_Requests - requests from the client to the server
* LSP.Messages.Server_Notifications - notifications from the client to the server
* LSP.Messages.Server_Responses - responses from the server to the client
* LSP.Messages.Client_Requests - requests from the server to the client
* LSP.Messages.Client_Notifications - notifications from the server to the client
* LSP.Messages.Client_Responses - responses from the client to the server

`Server_Requests` and `Server_Notifications` packages are generated by
`scripts/generate.py` script.

Each of these 6 packages defines common root type and `Visit` subprogram
to implement Visitor pattern. Corresponding visitors are defined in
packages:

* LSP.Server_Request_Receivers
* LSP.Server_Notification_Receivers
* Server_Response_Sender
* LSP.Client_Request_Receivers
* LSP.Client_Notification_Receivers
* LSP.Client_Response_Senders

The type `Message_Logger` implements all of these to provide custom format
for each message kind in the trace.

LSP server uses its-own `Server_Request_Handler` interface. This
interface defines functions corresponding to client-to-server LSP requests.
Function profiles ensure correct argument and result types at compile time.

`LSP.Ada_Handlers` implements `Server_Request_Handler` and
`Server_Notification_Receiver` interfaces to provide Ada language support.
It leverages `Server` to send notification to the client.

`Error_Decorator` also implements `Server_Request_Handler` and
provides safety net to catch Property_Error exceptions during
request processing.

LSP `Server`, on its side, converts messages to/from JSON,
tracks request Ids and implements `CancelRequest` logic.

`LSP.Ada_Documents.Document` type represents a file opened in an editor.
It keeps text of a changed file.

`LSP.Ada_Contexts.Context` type represent non-aggregate project tree
and keeps Libadalang context to process compilation units from this tree.

`Document` and `Context` objects belong to `Ada_Handler`.
