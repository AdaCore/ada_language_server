import { X2jOptions, XMLParser } from 'fast-xml-parser';
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { TestItem } from 'vscode';
import { integer } from 'vscode-languageclient';
import { adaExtState } from './extension';
import { exe, getObjectDir } from './helpers';

export let controller: vscode.TestController;
export let testRunProfile: vscode.TestRunProfile;

/**
 * Types definition for the Gnattest XML file structure. The types match the XML
 * generated by src/test-mapping.adb in the libadalang-tools repository.
 */
export type Root = {
    tests_mapping: TestMapping;
};

type TestMapping = {
    '@_mode': string;
    unit: Unit[];
    additional_tests: object[];
};

type Unit = {
    '@_source_file': string;
    test_unit: TestUnit[];
};

type TestUnit = {
    '@_target_file': string;
    tested: Tested[];
    dangling: Dangling;
};

type Tested = {
    '@_line': string;
    '@_column': string;
    '@_name': string;
    test_case: TestCase[];
};

type TestCase = {
    '@_name': string;
    '@_line': string;
    '@_column': string;
    test: Test;
};

type Test = {
    '@_file': string;
    '@_line': string;
    '@_column': string;
    '@_name': string;
};

type Dangling = {
    test: Test[];
};

/**
 * The XML paths in GNATtest XML files that should always be parsed as arrays.
 * This is based the code in src/test-mapping.adb in the libadalang-tools
 * repository which emits the XML.
 */
const alwaysArray = [
    'tests_mapping.unit',
    'tests_mapping.unit.test_unit',
    'tests_mapping.unit.test_unit.tested',
    'tests_mapping.unit.test_unit.tested.test_case',
    'tests_mapping.unit.test_unit.dangling.test',
    'tests_mapping.additional_tests',
];

/**
 * The types of TestItem nodes that we will be creating in the tree of TestItems
 * maintained by the test controller.
 */
enum TestItemType {
    Unit,
    Subprogram,
    Test,
}

/**
 * A data object that TestItems map to for additional data from the XML parsing.
 */
type TestItemData = {
    type: TestItemType;
    data?: object;
};

/**
 * A map from TestItem objects to their respective TestItemData objects.
 */
const testData: Map<vscode.TestItem, TestItemData> = new Map();

/**
 * This function initializes the test features of the extension.
 *
 * @param context - the ExtensionContext
 * @returns the {@link TestController}
 */
export function initializeTesting(context: vscode.ExtensionContext): vscode.TestController {
    controller = vscode.tests.createTestController(
        'gnattest-test-controller',
        'GNATtest Test Controller'
    );
    context.subscriptions.push(controller);

    controller.resolveHandler = resolveHandler;

    // Refresh Button to re discover the tests on the project.
    controller.refreshHandler = refreshHandler;

    // configureTestRunning(controller, projectFile, gnattestPath);

    return controller;
}
async function refreshHandler() {
    controller.items.replace([]);
    adaExtState.testData.clear();
    await addTestsRootLevel();
}

/*
    Run Profile and other options configuration for the Test Controller
*/
function configureTestRunning(
    controller: vscode.TestController,
    projectFileFullPath: string,
    gnattestFullPath: string
) {
    // terminal ID to seperate between each run
    let terminal_id = 0;
    // the controller's Run Handler
    const runHandler = (request: vscode.TestRunRequest) => {
        if (request.include == undefined) {
            // The Run All tests request
            const run = controller.createTestRun(request, undefined, false);
            const tests = gatherChildTestItems(controller.items);
            const terminal_name = 'Test_terminal_' + terminal_id.toString();
            // Run all tests handler
            handleRunAll(tests, run, terminal_name, gnattestFullPath);
            terminal_id++;
            // Parse the results when the terminal is closed
            vscode.window.onDidCloseTerminal(async (terminal) => {
                if (terminal.name == terminal_name) {
                    const file = await readResultFile(path.join(gnattestFullPath, 'result.txt'));
                    if (file != undefined) {
                        parseResults(tests, run, file);
                    }
                    run.end();
                }
            });
        } else {
            // specifique tests run request
            const run = controller.createTestRun(request, undefined, false);
            const tests = gatherChildTestItems(request.include);
            // create a temporary terminal to execute the command lines then close it.
            const terminalName = 'Test_terminal_' + terminal_id.toString();
            // test unit run handler
            handleUnitRun(tests, run, terminalName, gnattestFullPath);
            terminal_id++;
            // Parse the results when the terminal is closed
            vscode.window.onDidCloseTerminal(async (terminal) => {
                if (terminal.name == terminalName) {
                    const file = await readResultFile(path.join(gnattestFullPath, 'result.txt'));
                    if (file != undefined) {
                        parseResults(tests, run, file);
                    }
                    run.end();
                }
            });
        }
    };

    testRunProfile = controller.createRunProfile(
        'GNATtest',
        vscode.TestRunProfileKind.Run,
        runHandler,
        true,
        undefined
    );
    // Tests Configuration Handler to Generates Tests for a Project.
    testRunProfile.configureHandler = () => {
        const terminal = vscode.window.createTerminal('Test Terminal');
        terminal.sendText('gnattest -P ' + projectFileFullPath);
        terminal.sendText('exit');
    };
}

/*
    Run all tests handler
*/
export function handleRunAll(
    tests: vscode.TestItem[],
    run: vscode.TestRun,
    terminalName: string,
    gnattestPath: string
) {
    tests.forEach((item) => {
        run.appendOutput(`Running ${item.id}\r\n`);
        run.started(item);
    });
    // create a temporary terminal to execute the command lines then close it.
    const ext: string = process.platform == 'win32' ? '.exe' : '';
    const terminal = vscode.window.createTerminal(terminalName);
    terminal.sendText('gprbuild -P ' + path.join(gnattestPath, 'harness', 'test_driver.gpr'));
    terminal.sendText(
        path.join(gnattestPath, 'harness', 'test_runner' + ext) +
            ' > ' +
            path.join(gnattestPath, 'result.txt')
    );
    terminal.sendText('exit');
}

/*
    test unit/case run handler
*/
function handleUnitRun(
    tests: vscode.TestItem[],
    run: vscode.TestRun,
    terminalName: string,
    gnattestPath: string
) {
    const terminal = vscode.window.createTerminal(terminalName);
    const ext: string = process.platform == 'win32' ? '.exe' : '';
    // clean the previous results
    terminal.sendText('> ' + path.join(gnattestPath, 'result.txt'));
    // run every test case seperatly and append the results
    for (const test of tests) {
        run.appendOutput(`Running ${test.id}\r\n`);
        run.started(test);
        const parent = getParentTestSourceName(test);
        const p: integer | undefined = test.parent?.range?.start.line;
        const line: integer = p ? p + 1 : 0;
        terminal.sendText('gprbuild -P ' + path.join(gnattestPath, 'harness', 'test_driver.gpr'));
        terminal.sendText(
            path.join(gnattestPath, 'harness', 'test_runner' + ext) +
                ' --routines=' +
                parent.id +
                ':' +
                line.toString() +
                ' >> ' +
                path.join(gnattestPath, 'result.txt')
        );
    }
    terminal.sendText('exit');
}

/*
    Resolves Tests to run for a selected test item in the Explorer
*/
export function gatherChildTestItems(
    collection: vscode.TestItemCollection | readonly vscode.TestItem[]
): vscode.TestItem[] {
    let items: vscode.TestItem[] = [];
    collection.forEach((item) => {
        if (item.children.size == 0) {
            items.push(item);
        } else {
            items = items.concat(gatherChildTestItems(item.children));
        }
    });
    return items;
}

/*
    Gets the Source file name for a test item
    Needed for the --routines switch
*/
export function getParentTestSourceName(item: vscode.TestItem) {
    let parent: vscode.TestItem = item;
    if (item.parent != undefined) {
        parent = getParentTestSourceName(item.parent);
    }
    return parent;
}

/*
    Return the test_runner output stored in the result.txt file
*/
export async function readResultFile(resultPath: string) {
    if (vscode.workspace.workspaceFolders !== undefined) {
        if (pathIsReadable(resultPath)) {
            const file = await vscode.workspace.fs.readFile(vscode.Uri.file(resultPath));
            return file.toString();
        }
    }
    return undefined;
}

enum Test_State {
    PASSED = 'PASSED',
    FAILED = 'FAILED',
}

/*
    Parses the result of the file 'result.txt'
*/
export function parseResults(
    tests: vscode.TestItem[],
    run: vscode.TestRun | undefined,
    file: string
): boolean {
    const matchs = file.match(
        /(^|\n)((\w|-)+).ad[b|s]:\d+:\d+: (info|error): corresponding test (\w+)/g
    );
    if (matchs) {
        for (let i = 0; i < matchs.length; i++) {
            matchs[i] = matchs[i].replace(/\n/, '');
            for (const e of tests) {
                // Check if the result line is for the test 'e'
                const test_src = getParentTestSourceName(e);
                const p: integer | undefined = e.parent?.range?.start.line;
                const test_line: integer = p ? p + 1 : 0;
                const check_line = matchs[i].match(test_src.label + ':' + test_line.toString());
                // update the state of the test
                if (check_line != null && run != undefined) {
                    run.appendOutput(`Completed ${e.id}\r\n`);
                    const mm: string = matchs[i].substring(matchs[i].length - 6, matchs[i].length);
                    if (mm == Test_State.PASSED) {
                        run.passed(e);
                    } else {
                        run.failed(e, new vscode.TestMessage(matchs[i]));
                    }
                }
            }
        }
        return true;
    }
    return false;
}

async function getGnatTestXmlPath(): Promise<string> {
    const objDir = await getObjectDir();
    const gnatTestXmlPath = path.join(objDir, 'gnattest', 'harness', 'gnattest.xml');
    return gnatTestXmlPath;
}

export async function addTestsRootLevel() {
    if (fs.existsSync(await getGnatTestXmlPath())) {
        const xmlDoc: Root = await parseGnatTestXml();
        const rootNode = xmlDoc.tests_mapping;
        for (const u of rootNode.unit) {
            await addUnitItem(u);
        }
    }
}

async function parseGnatTestXml() {
    const gnatTestXmlUri = vscode.Uri.file(await getGnatTestXmlPath());
    const fileContent = await vscode.workspace.fs.readFile(gnatTestXmlUri);
    const fileContentAsBuffer = Buffer.from(fileContent);

    const options: Partial<X2jOptions> = {
        // By default the parser ignores attributes, so we set this option
        // to obtain attributes.
        ignoreAttributes: false,
        // This prefix is used in the JS objects resulting from the parsing
        // to differenciate attributes from child nodes.
        attributeNamePrefix: '@_',
        isArray: (_, jPath) => {
            return alwaysArray.indexOf(jPath) !== -1;
        },
    };
    const parser = new XMLParser(options);
    const xmlDoc: Root = parser.parse(fileContentAsBuffer) as Root;
    return xmlDoc;
}

/*
    Creating nested test items to visuliaze in the view
*/
async function addUnitItem(unit: Unit) {
    const srcFile = unit['@_source_file'];
    const srcUri = await findFileInWorkspace(srcFile);
    const unitId = createUnitItemId(unit);
    const testItem = controller.createTestItem(unitId, `Tests for ${srcFile}`, srcUri);

    /**
     * To implement lazy loading of children, we set canResolveChildren and
     * store the XML data in a map so that it can be processed later when the UI
     * needs it. The API guarantees that the testItem object will be the same at
     * resolve-time, i.e. it can be used as a key in a data map.
     */
    testItem.canResolveChildren = true;
    testData.set(testItem, { type: TestItemType.Unit, data: unit });

    controller.items.add(testItem);
}

function resolveUnitItem(testItem: TestItem, unit: Unit) {
    for (const t of unit.test_unit.flatMap((u) => u.tested)) {
        addTestedItem(testItem, t);
    }
}

/*
    Adding Test Cases to a Test Unit Item
*/
function addTestedItem(parentTestItem: vscode.TestItem, tested: Tested) {
    const testedSubprogramName = tested['@_name'];
    const pos = new vscode.Position(
        parseInt(tested['@_line']) - 1,
        parseInt(tested['@_column']) - 1
    );
    const range = new vscode.Range(pos, pos);

    const testItemId = createSubprogramItemId(tested);
    const testedItem = controller.createTestItem(
        testItemId,
        `Tests for subprogram ${testedSubprogramName}`,
        parentTestItem.uri
    );
    testedItem.range = range;

    /**
     * To implement lazy loading of children, we set canResolveChildren and
     * store the XML data in a map so that it can be processed later when the UI
     * needs it. The API guarantees that the testItem object will be the same at
     * resolve-time, i.e. it can be used as a key in a data map.
     */
    testedItem.canResolveChildren = true;
    testData.set(testedItem, { type: TestItemType.Subprogram, data: tested });

    parentTestItem.children.add(testedItem);
}

async function resolveTestedItem(testItem: TestItem, tested: Tested) {
    for (const e of tested.test_case) {
        await addTestCaseItem(testItem, e);
    }
}

/*
    Adding Test Childs to a Test Case Item
*/
async function addTestCaseItem(parentItem: vscode.TestItem, testCase: TestCase) {
    const test: Test = testCase.test;
    const testFileBasename = test['@_file'];
    const pos = new vscode.Position(parseInt(test['@_line']), parseInt(test['@_column']) - 1);
    const range = new vscode.Range(pos, pos);
    const testUri = await findFileInWorkspace(testFileBasename);

    // The name of the source file of the tested subprogram is not part of the
    // TestCase object, so we have to get it from the TestItem tree 2 levels
    // above.
    const srcFileName = parentItem.parent?.id;
    assert(srcFileName);
    const testId = createTestCaseItemId(testCase, srcFileName);

    /**
     * We use the test ID as a name so that it can be easily matched by the User
     * with the test driver output if needed.
     */
    const testCaseItem = controller.createTestItem(testId, testId, testUri);
    testCaseItem.range = range;
    parentItem.children.add(testCaseItem);
    testData.set(testCaseItem, { type: TestItemType.Test, data: testCase });
}

/**
 *
 * @param unit - a Unit object from the GNATtest XML
 * @returns a unique identifier to be used with the corresponding TestItem in VS Code
 */
function createUnitItemId(unit: Unit) {
    return unit['@_source_file'];
}

/**
 *
 * @param tested - a Tested object from the GNATtest XML
 * @returns an identifier to be used with the corresponding TestItem in VS Code
 * that is unique within the parent TestItem
 */
function createSubprogramItemId(tested: Tested) {
    /**
     * Due to the possibility of overloading in Ada, the subprogram name might
     * not be unique within the file. So this ID includes more info to ensure
     * uniqueness.
     */
    return `${tested['@_name']} ${tested['@_line']}:${tested['@_column']}`;
}

/**
 *
 * @param testCase - a TestCase object from the GNATtest XML
 * @param sourceFileName - the tested source file of the TestCase object (since
 * this information is not stored within the TestCase object itself)
 * @returns a unique identifier to be used with the corresponding TestItem in VS
 * Code. We choose the same convention as GNATtest in order to match identifiers
 * in VS Code with test results on the test driver output.
 */
function createTestCaseItemId(testCase: TestCase, sourceFileName: string): string {
    return `${sourceFileName}:${testCase['@_line']}:${testCase['@_column']}`;
}

async function findFileInWorkspace(name: string): Promise<vscode.Uri> {
    const matchingFiles = await vscode.workspace.findFiles(`**/${name}`, undefined, 1);
    if (matchingFiles.length > 0) {
        return matchingFiles[0];
    } else {
        throw `Source file ${name} not found in workspace`;
    }
}

/**
 * @param p - path to file or directory
 * @returns true if the path exists and access rights allow reading it, otherwise false
 */
export function pathIsReadable(p: string): boolean {
    try {
        if (!fs.existsSync(p)) {
            return false;
        }
        fs.accessSync(p, fs.constants.R_OK);
        return true;
    } catch (err) {
        return false;
    }
}

/**
 * This handler is called when the UI needs to expand a TestItem that has
 * children. It is supposed to compute the children of the TestItem being
 * expanded.
 *
 * @param item - the TestItem whose children must be computed, or `undefined` if
 * we should compute the root items of the tree.
 */
async function resolveHandler(item: TestItem | undefined) {
    if (!item) {
        /**
         * Register a file watcher to listen to changes to the GNATtest XML file
         */
        const watcher = vscode.workspace.createFileSystemWatcher(await getGnatTestXmlPath());
        // Add to extension disposables
        adaExtState.context.subscriptions.push(watcher);

        watcher.onDidCreate(refreshTestItemTree);
        watcher.onDidDelete(refreshTestItemTree);
        watcher.onDidChange(refreshTestItemTree);

        // Perform an initial load of tests
        await refreshTestItemTree();
    } else {
        const data = adaExtState.testData.get(item);
        if (data) {
            if ('test_unit' in data) {
                // It's a Unit object
                resolveUnitItem(item, data as Unit);
            } else if ('test' in data) {
                // It's a Dangling object
                await resolveDanglingItem(item, data as Dangling);
            } else {
                // It's a Tested object
                await resolveTestedItem(item, data as Tested);
            }
        }
    }
}
